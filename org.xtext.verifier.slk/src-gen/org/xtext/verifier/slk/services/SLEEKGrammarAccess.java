/*
* generated by Xtext
*/
package org.xtext.verifier.slk.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class SLEEKGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class SLEEKElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SLEEK");
		private final Assignment cKeywordsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cKeywordsArguParserRuleCall_0 = (RuleCall)cKeywordsAssignment.eContents().get(0);
		
		//SLEEK:
		//	keywords+=Argu*;
		public ParserRule getRule() { return rule; }

		//keywords+=Argu*
		public Assignment getKeywordsAssignment() { return cKeywordsAssignment; }

		//Argu
		public RuleCall getKeywordsArguParserRuleCall_0() { return cKeywordsArguParserRuleCall_0; }
	}

	public class ArguElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Argu");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrecoditionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDataParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLemmaParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cArgumentParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cPrintParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Argu:
		//	Precodition | Data | Lemma | Argument | Print;
		public ParserRule getRule() { return rule; }

		//Precodition | Data | Lemma | Argument | Print
		public Alternatives getAlternatives() { return cAlternatives; }

		//Precodition
		public RuleCall getPrecoditionParserRuleCall_0() { return cPrecoditionParserRuleCall_0; }

		//Data
		public RuleCall getDataParserRuleCall_1() { return cDataParserRuleCall_1; }

		//Lemma
		public RuleCall getLemmaParserRuleCall_2() { return cLemmaParserRuleCall_2; }

		//Argument
		public RuleCall getArgumentParserRuleCall_3() { return cArgumentParserRuleCall_3; }

		//Print
		public RuleCall getPrintParserRuleCall_4() { return cPrintParserRuleCall_4; }
	}

	public class DataElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Data");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDataKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSLKTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Data:
		//	"data" name=SLK;
		public ParserRule getRule() { return rule; }

		//"data" name=SLK
		public Group getGroup() { return cGroup; }

		//"data"
		public Keyword getDataKeyword_0() { return cDataKeyword_0; }

		//name=SLK
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//SLK
		public RuleCall getNameSLKTerminalRuleCall_1_0() { return cNameSLKTerminalRuleCall_1_0; }
	}

	public class LemmaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Lemma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLemmaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSLKTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Lemma:
		//	"lemma" name=SLK;
		public ParserRule getRule() { return rule; }

		//"lemma" name=SLK
		public Group getGroup() { return cGroup; }

		//"lemma"
		public Keyword getLemmaKeyword_0() { return cLemmaKeyword_0; }

		//name=SLK
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//SLK
		public RuleCall getNameSLKTerminalRuleCall_1_0() { return cNameSLKTerminalRuleCall_1_0; }
	}

	public class PrecoditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Precodition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPredKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSLKTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Precodition:
		//	"pred" name=SLK;
		public ParserRule getRule() { return rule; }

		//"pred" name=SLK
		public Group getGroup() { return cGroup; }

		//"pred"
		public Keyword getPredKeyword_0() { return cPredKeyword_0; }

		//name=SLK
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//SLK
		public RuleCall getNameSLKTerminalRuleCall_1_0() { return cNameSLKTerminalRuleCall_1_0; }
	}

	public class ArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Argument");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCheckentailKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSLKTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Argument:
		//	"checkentail" name=SLK;
		public ParserRule getRule() { return rule; }

		//"checkentail" name=SLK
		public Group getGroup() { return cGroup; }

		//"checkentail"
		public Keyword getCheckentailKeyword_0() { return cCheckentailKeyword_0; }

		//name=SLK
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//SLK
		public RuleCall getNameSLKTerminalRuleCall_1_0() { return cNameSLKTerminalRuleCall_1_0; }
	}

	public class PrintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Print");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPrintKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSLKTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Print:
		//	"print" name=SLK;
		public ParserRule getRule() { return rule; }

		//"print" name=SLK
		public Group getGroup() { return cGroup; }

		//"print"
		public Keyword getPrintKeyword_0() { return cPrintKeyword_0; }

		//name=SLK
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//SLK
		public RuleCall getNameSLKTerminalRuleCall_1_0() { return cNameSLKTerminalRuleCall_1_0; }
	}
	
	
	private final SLEEKElements pSLEEK;
	private final ArguElements pArgu;
	private final DataElements pData;
	private final LemmaElements pLemma;
	private final PrecoditionElements pPrecodition;
	private final ArgumentElements pArgument;
	private final PrintElements pPrint;
	private final TerminalRule tSLK;
	private final TerminalRule tML_COMMENT;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public SLEEKGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pSLEEK = new SLEEKElements();
		this.pArgu = new ArguElements();
		this.pData = new DataElements();
		this.pLemma = new LemmaElements();
		this.pPrecodition = new PrecoditionElements();
		this.pArgument = new ArgumentElements();
		this.pPrint = new PrintElements();
		this.tSLK = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SLK");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.verifier.slk.SLEEK".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//SLEEK:
	//	keywords+=Argu*;
	public SLEEKElements getSLEEKAccess() {
		return pSLEEK;
	}
	
	public ParserRule getSLEEKRule() {
		return getSLEEKAccess().getRule();
	}

	//Argu:
	//	Precodition | Data | Lemma | Argument | Print;
	public ArguElements getArguAccess() {
		return pArgu;
	}
	
	public ParserRule getArguRule() {
		return getArguAccess().getRule();
	}

	//Data:
	//	"data" name=SLK;
	public DataElements getDataAccess() {
		return pData;
	}
	
	public ParserRule getDataRule() {
		return getDataAccess().getRule();
	}

	//Lemma:
	//	"lemma" name=SLK;
	public LemmaElements getLemmaAccess() {
		return pLemma;
	}
	
	public ParserRule getLemmaRule() {
		return getLemmaAccess().getRule();
	}

	//Precodition:
	//	"pred" name=SLK;
	public PrecoditionElements getPrecoditionAccess() {
		return pPrecodition;
	}
	
	public ParserRule getPrecoditionRule() {
		return getPrecoditionAccess().getRule();
	}

	//Argument:
	//	"checkentail" name=SLK;
	public ArgumentElements getArgumentAccess() {
		return pArgument;
	}
	
	public ParserRule getArgumentRule() {
		return getArgumentAccess().getRule();
	}

	//Print:
	//	"print" name=SLK;
	public PrintElements getPrintAccess() {
		return pPrint;
	}
	
	public ParserRule getPrintRule() {
		return getPrintAccess().getRule();
	}

	//terminal SLK:
	//	WS+ !"."* "|-"? !"."* "." WS*;
	public TerminalRule getSLKRule() {
		return tSLK;
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\""))* "\"" | "\'" ("\\" .
	//	/ * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
